Botão "Terminar no ponto inicial" com exemplos Python completos
1. Front-end (React): Toggle + Envio
Adicione um estado no componente Routes.tsx:

javascript
Copiar
Editar
const [terminarNoPontoInicial, setTerminarNoPontoInicial] = useState(false);
Adicione um checkbox ou switch visual ao lado do botão "Otimizar Rota":

jsx
Copiar
Editar
<div className="flex items-center gap-2 mb-3">
  <input
    type="checkbox"
    id="terminarNoPontoInicial"
    checked={terminarNoPontoInicial}
    onChange={e => setTerminarNoPontoInicial(e.target.checked)}
    className="mr-2"
  />
  <label htmlFor="terminarNoPontoInicial" className="text-sm font-medium">
    Terminar no ponto inicial
  </label>
</div>
No handleOptimizeRoute, envie junto:

javascript
Copiar
Editar
const tspData = await fetch("/api/rota/tsp", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    matrix: matrixData.matrix,
    terminarNoPontoInicial, // este campo novo!
  }),
});
2. Backend (Node/Express): Receber e passar ao Python
No endpoint /api/rota/tsp, adicione o parâmetro:

javascript
Copiar
Editar
app.post('/api/rota/tsp', async (req, res) => {
  const { matrix, terminarNoPontoInicial } = req.body;

  const { spawn } = require('child_process');
  const py = spawn('python3', ['server/solve_tsp.py']);

  py.stdin.write(JSON.stringify({ matrix, terminarNoPontoInicial })); // envia para o Python
  py.stdin.end();

  let output = '';
  py.stdout.on('data', (data) => output += data);
  py.stderr.on('data', (data) => console.error('py err:', data.toString()));

  py.on('close', (code) => {
    try {
      const result = JSON.parse(output);
      return res.json(result);
    } catch (e) {
      return res.status(500).json({ error: 'Erro no Python', details: output });
    }
  });
});
3. Python (solve_tsp.py): Controle total do tipo de rota
Exemplo COMPLETO de solve_tsp.py
(coloque na raiz server/ ou ajuste o path do spawn)

python
Copiar
Editar
import sys
import json
from ortools.constraint_solver import pywrapcp, routing_enums_pb2

# Lê dados do Node.js
data = json.load(sys.stdin)
matrix = data["matrix"]
terminar_no_ponto_inicial = data.get("terminarNoPontoInicial", False)

def create_data_model():
    return {
        'distance_matrix': matrix,
        'num_vehicles': 1,
        'depot': 0  # ponto inicial sempre é o 0
    }

def main():
    data_model = create_data_model()
    manager = pywrapcp.RoutingIndexManager(
        len(data_model['distance_matrix']),
        data_model['num_vehicles'],
        data_model['depot'],
    )

    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return int(data_model['distance_matrix'][from_node][to_node])

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    # LÓGICA DO FIM DA ROTA
    if terminar_no_ponto_inicial:
        # Rota circular: começa e termina no ponto 0 (empresa/casa do técnico)
        end = 0
    else:
        # Rota aberta: começa no ponto 0, termina em qualquer outro ponto (cliente mais distante)
        end = manager.NodeToIndex(len(matrix) - 1)  # geralmente último ponto, ou escolha dinamicamente

    # IMPORTANTE: SetStartAndEnd exige índice na forma "Index", não "Node"
    routing.SetStartAndEnd(manager.NodeToIndex(0), end)

    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
    )
    search_parameters.local_search_metaheuristic = (
        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH
    )
    search_parameters.time_limit.seconds = 10

    solution = routing.SolveWithParameters(search_parameters)

    result = {
        'order': [],
        'totalDistance': 0,
        'totalTime': 0,
        'legs': []
    }

    if solution:
        index = routing.Start(0)
        route = []
        total_distance = 0
        legs = []

        while not routing.IsEnd(index):
            node_index = manager.IndexToNode(index)
            route.append(node_index)

            previous_index = index
            index = solution.Value(routing.NextVar(index))
            if not routing.IsEnd(index):
                # Distância do trecho atual
                next_node = manager.IndexToNode(index)
                leg_distance = data_model['distance_matrix'][node_index][next_node]
                legs.append({
                    'from': node_index,
                    'to': next_node,
                    'distance': leg_distance,
                    'duration': leg_distance // 60  # se matriz em segundos (exemplo)
                })
                total_distance += leg_distance

        # Adiciona o último nó do trajeto
        last_node = manager.IndexToNode(index)
        route.append(last_node)

        result['order'] = route
        result['totalDistance'] = total_distance  # em metros ou segundos conforme matriz
        result['legs'] = legs
        # Para tempo total, se matriz for em segundos: total_distance // 60 (minutos)
        result['totalTime'] = total_distance // 60
    else:
        result['error'] = 'No solution found!'

    print(json.dumps(result))

if __name__ == "__main__":
    main()
Comentários importantes para IA:

Rota circular: SetStartAndEnd(manager.NodeToIndex(0), manager.NodeToIndex(0))

Rota aberta: SetStartAndEnd(manager.NodeToIndex(0), manager.NodeToIndex(len(matrix) - 1))

Dê preferência para deixar o código flexível: se quiser que o ponto final seja outro, mude end para outro índice conforme regra de negócio.

O campo 'order' deve ser o array de índices dos pontos na sequência da rota (incluindo o inicial e o final).

O campo 'legs' contém os detalhes de cada trecho da rota (ponto de, ponto para, distância, tempo).

4. UI: Indique visualmente a opção
No topo da tela, exiba uma mensagem dinâmica:

jsx
Copiar
Editar
<span className="text-xs text-gray-500">
  {terminarNoPontoInicial
    ? "A rota irá terminar no ponto inicial"
    : "A rota irá terminar no cliente mais distante"}
</span>