deu pra ver o porqu√™ do UNDO n√£o voltar. O problema est√° no /api/routes/:routeId/stops/restore: voc√™ checa Number.isFinite(client.lat) e client.lng sem converter pra n√∫mero. Em Postgres (e no Drizzle), numeric/decimal costuma vir como string, ent√£o a checagem falha e o endpoint retorna ‚ÄúCliente sem coordenadas v√°lidas‚Äù, mesmo tendo lat/lng v√°lidos.

Al√©m disso, √© bom ter fallback: se o cliente n√£o tiver coordenadas, geocodificar o endere√ßo do agendamento (e, se necess√°rio, o endere√ßo do cliente).

Abaixo vai um patch direto, pronto pra colar. Ele:

Converte lat/lng pra number antes de validar

Faz fallback de geocodifica√ß√£o pelo endere√ßo do agendamento (e depois pelo do cliente)

Monta o address direitinho

Insere a parada e atualiza o contador

‚úÖ Patch no backend (server/routes/routes.api.ts)

Substitua TODO o endpoint /stops/restore pelo abaixo:

// POST /api/routes/:routeId/stops/restore - Restaurar parada removida (para UNDO)
app.post(
  "/api/routes/:routeId/stops/restore",
  authenticateToken,
  async (req: any, res: Response) => {
    try {
      const { routeId } = req.params;
      const { appointmentId } = req.body;

      if (appointmentId == null) {
        return res.status(400).json({ message: "appointmentId √© obrigat√≥rio" });
      }

      const apptIdNum = Number(appointmentId);
      if (!Number.isFinite(apptIdNum)) {
        return res.status(400).json({ message: "appointmentId inv√°lido" });
      }

      console.log(`üîÑ Restaurando agendamento ${apptIdNum} na rota ${routeId}`);

      // Verificar se a rota existe
      const [route] = await db
        .select({ id: routesTbl.id })
        .from(routesTbl)
        .where(eq(routesTbl.id, routeId))
        .limit(1);

      if (!route) {
        return res.status(404).json({ message: "Rota n√£o encontrada" });
      }

      // Buscar o agendamento (inclui endere√ßo)
      const [appt] = await db
        .select({
          id: appointments.id,
          clientId: appointments.clientId,
          cep: appointments.cep,
          logradouro: appointments.logradouro,
          numero: appointments.numero,
          complemento: appointments.complemento,
          bairro: appointments.bairro,
          cidade: appointments.cidade,
        })
        .from(appointments)
        .where(eq(appointments.id, apptIdNum))
        .limit(1);

      if (!appt) {
        return res.status(404).json({ message: "Agendamento n√£o encontrado" });
      }

      // Buscar cliente (p/ lat/lng e endere√ßo fallback)
      const [cli] = await db
        .select({
          id: clients.id,
          lat: clients.lat,
          lng: clients.lng,
          cep: clients.cep,
          logradouro: clients.logradouro,
          numero: clients.numero,
          complemento: clients.complemento,
          bairro: clients.bairro,
          cidade: clients.cidade,
        })
        .from(clients)
        .where(eq(clients.id, appt.clientId!))
        .limit(1);

      // ‚ö†Ô∏è Converter lat/lng retornados do DB para number
      let lat = cli?.lat != null ? Number(cli.lat) : NaN;
      let lng = cli?.lng != null ? Number(cli.lng) : NaN;

      // Endere√ßos ‚Äúbonitinhos‚Äù
      const addrFromAppt = [appt.logradouro, appt.numero, appt.bairro, appt.cidade, appt.cep, "Brasil"]
        .filter(Boolean)
        .join(", ");

      const addrFromClient = [cli?.logradouro, cli?.numero, cli?.bairro, cli?.cidade, cli?.cep, "Brasil"]
        .filter(Boolean)
        .join(", ");

      // Se cliente n√£o tem coordenadas v√°lidas, geocodifica (1) endere√ßo do agendamento; (2) endere√ßo do cliente
      if (!(Number.isFinite(lat) && Number.isFinite(lng))) {
        try {
          if (addrFromAppt) {
            const g1 = await geocodeEnderecoServer(addrFromAppt);
            lat = Number(g1.lat);
            lng = Number(g1.lon);
            console.log("üìå Geocodificado via endere√ßo do agendamento:", addrFromAppt, lat, lng);
          }
        } catch (e: any) {
          console.warn("‚ö†Ô∏è Geocodifica√ß√£o pelo agendamento falhou:", e.message);
        }

        if (!(Number.isFinite(lat) && Number.isFinite(lng)) && addrFromClient) {
          try {
            const g2 = await geocodeEnderecoServer(addrFromClient);
            lat = Number(g2.lat);
            lng = Number(g2.lon);
            console.log("üìå Geocodificado via endere√ßo do cliente:", addrFromClient, lat, lng);
          } catch (e: any) {
            console.warn("‚ö†Ô∏è Geocodifica√ß√£o pelo cliente falhou:", e.message);
          }
        }
      }

      if (!(Number.isFinite(lat) && Number.isFinite(lng))) {
        return res.status(400).json({ message: "Sem coordenadas v√°lidas para restaurar a parada" });
      }

      // Pr√≥xima ordem
      const [maxOrderResult] = await db
        .select({ maxOrder: sql<number>`COALESCE(MAX(${stopsTbl.order}), 0)` })
        .from(stopsTbl)
        .where(eq(stopsTbl.routeId, routeId));

      const nextOrder = (maxOrderResult?.maxOrder ?? 0) + 1;

      // Endere√ßo a salvar na parada ‚Üí priorize o do agendamento (foi o usado na roteiriza√ß√£o)
      const addressToSave = addrFromAppt || addrFromClient;

      // Inserir a parada
      await db.insert(stopsTbl).values({
        routeId,
        appointmentId: numberToUUID(apptIdNum),
        order: nextOrder,
        lat: Number(lat.toFixed(6)),
        lng: Number(lng.toFixed(6)),
        address: addressToSave,
      });

      // Atualizar contador
      await db
        .update(routesTbl)
        .set({
          stopsCount: sql`${routesTbl.stopsCount} + 1`,
          updatedAt: sql`CURRENT_TIMESTAMP`,
        })
        .where(eq(routesTbl.id, routeId));

      console.log(`‚úÖ Agendamento ${apptIdNum} restaurado na rota ${routeId} (ordem ${nextOrder})`);

      return res.json({ ok: true, appointmentId: apptIdNum, routeId, order: nextOrder });
    } catch (e: any) {
      console.error("[restore stop] error:", e);
      return res.status(500).json({ message: "Falha ao restaurar parada" });
    }
  },
);


Observa√ß√£o: eu mantive sua fun√ß√£o geocodeEnderecoServer e o util numberToUUID. Sem eles o patch n√£o compila.

‚úÖ Confer√™ncia r√°pida no frontend

Seu front j√° est√° OK, s√≥ garanta que o appointmentId est√° indo como n√∫mero no UNDO (voc√™ j√° faz isso ao salvar lastRemoved). Confere o trecho:

// onde dispara a remo√ß√£o (no clique do bot√£o Remover)
const stop = routeDetail.stops.find(s => s.id === stopToRemove.id);
removeStopMutation.mutate({
  routeId: routeDetail.route.id,
  stopId: stopToRemove.id,
  appointmentId: Number(stop?.appointmentNumericId ?? stop?.appointmentId), // ‚úÖ n√∫mero
  clientName: stopToRemove.clientName
});


E a mutation do UNDO:

restoreStopMutation.mutate({
  routeId: lastRemoved.routeId,
  appointmentId: lastRemoved.appointmentId!, // j√° √© number
});


Se quiser logar a resposta do servidor, d√° pra colocar um console.log no onSuccess do restoreStopMutation.