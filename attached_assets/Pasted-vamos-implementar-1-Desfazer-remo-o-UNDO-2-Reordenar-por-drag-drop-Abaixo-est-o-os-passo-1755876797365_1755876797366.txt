vamos implementar (1) Desfazer remoção (UNDO) + (2) Reordenar por drag & drop.
Abaixo estão os passos enxutos com código pronto (na mesma pegada dos últimos ajustes), para a IA do Replit aplicar direto.

0) Dependências (drag & drop)

No client:

npm i @dnd-kit/core @dnd-kit/sortable @dnd-kit/modifiers

1) Backend — endpoint para reordenar paradas

Arquivo: server/routes/routes.api.ts
Adicione este endpoint:

// PATCH /api/routes/:routeId/stops/reorder
// Body: { stopIds: string[] } -> ordem final desejada (apenas IDs que pertencem à rota)
router.patch('/api/routes/:routeId/stops/reorder', async (req, res) => {
  const { routeId } = req.params as { routeId: string };
  const { stopIds } = req.body as { stopIds: string[] };

  if (!Array.isArray(stopIds) || stopIds.length === 0) {
    return res.status(400).json({ message: 'stopIds (array) é obrigatório' });
  }

  try {
    const { rows: existing } = await db.query(
      `SELECT id FROM route_stops WHERE route_id = $1 ORDER BY "order" ASC`,
      [routeId]
    );
    const setExisting = new Set(existing.map(r => r.id));

    for (const id of stopIds) {
      if (!setExisting.has(id)) {
        return res.status(400).json({ message: `Stop ${id} não pertence a esta rota` });
      }
    }

    await db.query('BEGIN');
    let i = 1;
    for (const id of stopIds) {
      await db.query(`UPDATE route_stops SET "order" = $1 WHERE id = $2`, [i++, id]);
    }
    await db.query('COMMIT');

    return res.json({ ok: true, routeId, stopIds });
  } catch (e) {
    await db.query('ROLLBACK');
    console.error('[reorder stops] error:', e);
    return res.status(500).json({ message: 'Falha ao reordenar paradas' });
  }
});


Dica: pode testar com:

curl -X PATCH http://localhost:5000/api/routes/<ROUTE_ID>/stops/reorder \
  -H "Content-Type: application/json" \
  -d '{"stopIds":["<STOP_ID_1>","<STOP_ID_2>", "..."]}'

2) Frontend — UNDO (desfazer) após remover
2.1 Imports extras

Arquivo: client/src/pages/routes-history/RoutesHistoryPage.tsx

No topo, além do que você já tem:

import { ToastAction } from "@/components/ui/toast";
import { GripVertical } from "lucide-react";

// dnd-kit
import {
  DndContext,
  closestCenter,
  PointerSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  SortableContext,
  verticalListSortingStrategy,
  arrayMove,
  useSortable,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";

2.2 Estado para lembrar a última remoção

Logo dentro do componente:

// Guarda a última parada removida para permitir "Desfazer"
const [lastRemoved, setLastRemoved] = useState<null | {
  routeId: string;
  stopId: string;
  appointmentId?: number; // numérico
  clientName?: string | null;
}>(null);

2.3 Mutation de remoção (use a que você já tem) — ajuste o onSuccess

No onSuccess da sua removeStopMutation (ou onde você trata a remoção com sucesso), salve os dados no lastRemoved antes de invalidar a query e mostre o toast com ação:

onSuccess: async (payload: { routeId: string; stopId: string; appointmentId?: number; clientName?: string | null }) => {
  // guarda infos para UNDO
  setLastRemoved({
    routeId: payload.routeId,
    stopId: payload.stopId,
    appointmentId: payload.appointmentId,
    clientName: payload.clientName,
  });

  toast({
    title: "Parada removida",
    description: `${payload.clientName || "Agendamento"} foi removido da rota.`,
    action: (
      <ToastAction altText="Desfazer" onClick={() => undoRemove()}>
        Desfazer
      </ToastAction>
    ),
  });

  // recarrega detalhe/lista normalmente
  queryClient.invalidateQueries({ queryKey: ["/api/routes", selectedRoute] });
  queryClient.invalidateQueries({ queryKey: ["/api/routes"] });
}


Se sua mutation de remoção ainda não retorna appointmentId e clientName, passe esses dados no momento de acionar a remoção (você tem no objeto stop do card). Ex.:

removeStopMutation.mutate({ routeId, stopId: stop.id, appointmentId: Number(stop.appointmentNumericId ?? stop.appointmentId), clientName: stop.clientName })

2.4 Função undoRemove()

Coloque no componente:

const undoRemove = () => {
  if (!lastRemoved?.routeId || !lastRemoved?.appointmentId) return;

  // re-adiciona o agendamento removido
  addStopsMutation.mutate({
    routeId: lastRemoved.routeId,
    appointmentIds: [String(lastRemoved.appointmentId)], // seu endpoint aceita string[]
  });

  // limpa memória local para não reaproveitar indevidamente
  setLastRemoved(null);
};


Obs.: o re-add entra no final da ordem; se quiser recolocar exatamente na posição antiga, veja a parte de reordenar abaixo (após re-add, você pode disparar um PATCH /reorder com a lista desejada).

3) Frontend — Reordenar por drag & drop

A ideia: só as paradas são “sortables” (o Início da rota não entra no DnD).

3.1 Estado local refletindo a lista de paradas
// Lista local (UI) para ordenar sem esperar round-trip
const [stopsUI, setStopsUI] = useState<RouteDetail["stops"]>([]);

// sempre que routeDetail mudar, sincroniza a UI (ordenado por "order")
useEffect(() => {
  const sorted = (routeDetail?.stops || [])
    .slice()
    .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
  setStopsUI(sorted);
}, [routeDetail?.stops]);

3.2 Mutation para persistir a nova ordem
const reorderStopsMutation = useMutation({
  mutationFn: async ({ routeId, stopIds }: { routeId: string; stopIds: string[] }) => {
    const res = await apiRequest("PATCH", `/api/routes/${routeId}/stops/reorder`, { stopIds });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.message || "Falha ao reordenar");
    }
    return res.json();
  },
  onError: (e: any) => {
    toast({
      title: "Erro ao reordenar",
      description: e?.message || "Tente novamente.",
      variant: "destructive",
    });
    // volta estado local (refetch)
    queryClient.invalidateQueries({ queryKey: ['/api/routes', selectedRoute] });
  },
  onSuccess: () => {
    // garantia de sincronismo
    queryClient.invalidateQueries({ queryKey: ['/api/routes', selectedRoute] });
  },
});

3.3 Sensores DnD e handler
const sensors = useSensors(
  useSensor(PointerSensor, { activationConstraint: { distance: 5 } })
);

const handleDragEnd = (event: any) => {
  const { active, over } = event;
  if (!over || active.id === over.id) return;

  const oldIndex = stopsUI.findIndex(s => s.id === active.id);
  const newIndex = stopsUI.findIndex(s => s.id === over.id);
  if (oldIndex < 0 || newIndex < 0) return;

  const newList = arrayMove(stopsUI, oldIndex, newIndex).map((s, idx) => ({
    ...s,
    order: idx + 1
  }));
  setStopsUI(newList);

  // persiste no back
  if (routeDetail?.route?.id) {
    reorderStopsMutation.mutate({
      routeId: routeDetail.route.id,
      stopIds: newList.map(s => s.id),
    });
  }
};

3.4 Item sortável com “handle” (Grip)

Coloque este helper no mesmo arquivo (acima do return):

function SortableStopItem({
  stop,
  children,
}: {
  stop: { id: string };
  children: React.ReactNode;
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    setActivatorNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: stop.id });

  const style: React.CSSProperties = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={style} className={isDragging ? "opacity-50" : ""}>
      {/* Handle de arraste */}
      <div className="flex items-center gap-2 mb-1">
        <button
          className="cursor-grab p-1 rounded hover:bg-gray-100"
          ref={setActivatorNodeRef}
          {...attributes}
          {...listeners}
          aria-label="Arrastar"
          title="Arrastar para reordenar"
        >
          <GripVertical className="w-4 h-4 text-gray-400" />
        </button>
      </div>
      {children}
    </div>
  );
}

3.5 Usar o DnD na renderização das paradas

No lugar onde você renderiza a lista de paradas (no modal, apenas a parte das paradas, não o card “Início da rota”), troque:

{/* Lista de paradas */}
<div>
  <h5 className="font-semibold text-sm sm:text-base mb-2 sm:mb-3">
    Paradas da Rota
  </h5>

  <div className="space-y-2">
    {/* Início da rota ... (deixa como está) */}

    {/* === Drag & Drop só nas paradas (stopsUI) === */}
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={stopsUI.map((s) => s.id)}
        strategy={verticalListSortingStrategy}
      >
        {stopsUI.map((stop) => (
          <SortableStopItem key={stop.id} stop={stop}>
            {/* === SEU CARD DE PARADA EXISTENTE (sem alterar lógica) === */}
            <div className="flex items-start gap-3 p-3 bg-gray-50 rounded-lg">
              <div className="flex-shrink-0 w-7 h-7 sm:w-8 sm:h-8 bg-burnt-yellow text-white rounded-full flex items-center justify-center text-sm font-bold">
                {stop.order}
              </div>
              <div className="flex-1">
                <div className="font-medium text-sm">
                  {stop.clientName ? stop.clientName : `Agendamento #${stop.appointmentId}`}
                </div>
                <div className="text-xs sm:text-sm text-gray-600 mt-1">{stop.address}</div>
                <div className="text-[11px] text-gray-500 mt-1">
                  {stop.lat.toFixed(6)}, {stop.lng.toFixed(6)}
                </div>
              </div>

              {/* seu botão X de remover (permanece igual) */}
              {/* ... */}
            </div>
          </SortableStopItem>
        ))}
      </SortableContext>
    </DndContext>
  </div>
</div>


Observações:

O “Início da rota” continua fora do DnD (não arrastável).

O grip (ícone de “três risquinhos”) é o handle; o restante do card continua clicável (X, etc.).

A cada drag solto, a UI já atualiza e é persistida via PATCH /reorder.

4) (Opcional) Recolocar no mesmo lugar ao “Desfazer”

Se você quiser que o UNDO recoloque na mesma posição antiga:

Guarde também previousOrder no lastRemoved.

Após o addStopsMutation retornar, faça um refetch do detalhe para pegar o novo id da parada recém-inserida, componha o array stopIds na ordem desejada e chame reorderStopsMutation.mutate({ routeId, stopIds }).

Isso é um plus; o fluxo básico acima já fica excelente.

Resultado

✅ Ao remover uma parada, aparece toast com Desfazer que re-adiciona o agendamento.

✅ Paradas podem ser reordenadas por arrastar e soltar, com persistência no backend.

✅ UX suave: handle de arraste, sem quebrar o clique no “X”, e sem arrastar o card de “Início da rota”.