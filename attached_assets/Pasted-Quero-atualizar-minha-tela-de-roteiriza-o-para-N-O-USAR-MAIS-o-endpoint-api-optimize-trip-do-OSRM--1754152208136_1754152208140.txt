Quero atualizar minha tela de roteirização para NÃO USAR MAIS o endpoint /api/optimize-trip do OSRM (que usa /trip).
Agora, quero usar o novo fluxo do backend:

/api/rota/matrix (POST) → devolve matriz de duração do OSRM

/api/rota/tsp (POST) → resolve a ordem ótima de visita com OR-Tools (Python/Google), sem retornar ao ponto inicial.

O que quero que faça:
1.
Encontre a função handleOptimizeRoute (em client/src/pages/Routes.tsx) e remova qualquer chamada ou referência à função otimizarRotaTsp e ao endpoint /api/optimize-trip.

2.
Altere a lógica do handleOptimizeRoute para seguir este fluxo:

Após geocodificar os endereços e montar o array todasCoordenadas (que já existe e tem a ordem [início, destino1, destino2...]):

Monte um array coordsArray com os pares [lon, lat] (atenção à ordem!):

js
Copiar
Editar
const coordsArray = todasCoordenadas.map(coord => [coord.lon, coord.lat]);
Chame o endpoint /api/rota/matrix (POST), enviando:

js
Copiar
Editar
{
  coords: coordsArray
}
E obtenha de volta:

js
Copiar
Editar
{ matrix: [...] }
Chame o endpoint /api/rota/tsp (POST), enviando:

js
Copiar
Editar
{
  matrix: matrixData.matrix
}
E obtenha de volta:

js
Copiar
Editar
{ order: [0, 2, 1, ...] }
Reordene os agendamentos selecionados (selecionados) com base na ordem retornada, ignorando o índice 0 (ponto inicial):

js
Copiar
Editar
const agendamentosOtimizados = tspData.order
  .filter(idx => idx > 0)
  .map(idx => selecionados[idx - 1]); // -1 porque selecionados[0] corresponde ao destino 1
Atualize o estado da tela com a nova ordem:

js
Copiar
Editar
setOptimizedRoute({
  optimizedOrder: agendamentosOtimizados,
  totalDistance: 0, // pode deixar 0 por enquanto, depois pode somar as distâncias reais se quiser
  estimatedTime: 0,
  geojson: null,
});
Mostre um toast de sucesso.

3.
Remova também a função otimizarRotaTsp se ela só for usada para o endpoint antigo.

Exemplo de como quero que fique a função handleOptimizeRoute:
js
Copiar
Editar
const handleOptimizeRoute = async () => {
  if (selectedAppointments.length === 0) {
    toast({ title: "Atenção", description: "Selecione pelo menos um agendamento para otimizar a rota", variant: "destructive" });
    return;
  }

  try {
    // ...geocodificação já existente, mantendo todasCoordenadas correto...

    const coordsArray = todasCoordenadas.map(coord => [coord.lon, coord.lat]);

    // 1. Chama backend para gerar matriz de durações
    const matrixRes = await fetch("/api/rota/matrix", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ coords: coordsArray }),
    });
    if (!matrixRes.ok) throw new Error("Erro ao calcular matriz: " + (await matrixRes.text()));
    const matrixData = await matrixRes.json();

    // 2. Resolve TSP (ordem ótima)
    const tspRes = await fetch("/api/rota/tsp", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ matrix: matrixData.matrix }),
    });
    if (!tspRes.ok) throw new Error("Erro ao otimizar rota: " + (await tspRes.text()));
    const tspData = await tspRes.json();

    // 3. Aplica a ordem ao array de agendamentos
    const agendamentosOtimizados = tspData.order
      .filter(idx => idx > 0)
      .map(idx => selecionados[idx - 1]);

    setOptimizedRoute({
      optimizedOrder: agendamentosOtimizados,
      totalDistance: 0,
      estimatedTime: 0,
      geojson: null,
    });

    toast({
      title: "Rota otimizada com sucesso!",
      description: `Rota calculada com ${agendamentosOtimizados.length} paradas.`,
    });
  } catch (error) {
    toast({
      title: "Erro",
      description: `Falha ao otimizar rota: ${error.message || error}`,
      variant: "destructive",
    });
  }
};
Resumo
NUNCA mais chame /api/optimize-trip.

Use apenas o fluxo /api/rota/matrix ➔ /api/rota/tsp como mostrado.

Me avise se precisa atualizar qualquer outro lugar do código para remover o TSP antigo.

IMPORTANTE:
Apenas altere a função de otimizar rota e remova o código morto do TSP/OSRM antigo.
Não altere outras partes do sistema.

